import React, { useState, useRef, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { supabase } from '../../utils/supabaseClient';
import logo from '../../assets/CacheFlow_Logo.png';
import viewPng from '../../assets/view.png';
import hidePng from '../../assets/hide.png';
import './OtpLogin.css';

function generateOTP() {
  // kept for compatibility; real OTP is generated by backend
  return null;
}

const OtpLogin = () => {
  const navigate = useNavigate();
  const [step, setStep] = useState('login'); // 'login' | 'otp'
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [otp, setOtp] = useState(['', '', '', '', '', '']);
  const [sentOtp, setSentOtp] = useState('');
  const [timer, setTimer] = useState(45);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);
  const [contactNumber, setContactNumber] = useState('');
  const [userId, setUserId] = useState('');
  const [info, setInfo] = useState('');
  const [attempts, setAttempts] = useState(0);
  const [lockUntil, setLockUntil] = useState(null);
  const [remaining, setRemaining] = useState(0);
  const [otpAttempts, setOtpAttempts] = useState(0);
  const [otpLockUntil, setOtpLockUntil] = useState(null);
  const [otpRemaining, setOtpRemaining] = useState(0);
  const [resendClicked, setResendClicked] = useState(false);
  
  const inputRefs = useRef([]);

  useEffect(() => {
    if (step === 'otp' && timer > 0) {
      const interval = setInterval(() => setTimer(t => t - 1), 1000);
      return () => clearInterval(interval);
    }
  }, [timer, step]);

  const handleChange = (idx, value) => {
    if (!/^[0-9]?$/.test(value)) return;
    const newOtp = [...otp];
    newOtp[idx] = value;
    setOtp(newOtp);
    if (value && idx < 5) {
      inputRefs.current[idx + 1].focus();
    }
  };

  const handleKeyDown = (idx, e) => {
    if (e.key === 'Backspace' && !otp[idx] && idx > 0) {
      inputRefs.current[idx - 1].focus();
    }
  };

  const handleLogin = async (e) => {
    e.preventDefault();
    setError('');
    setInfo('');
    
    setLoading(true);

    // respect lockout
    if (lockUntil && Date.now() < lockUntil) {
      setError(`Too many failed attempts. Try again in ${Math.ceil((lockUntil - Date.now()) / 1000)}s`);
      setLoading(false);
      return;
    }

    // Field validation: show specific messages for blank fields
    if (!username || username.trim() === '') {
      setError('Username is required');
      setLoading(false);
      return;
    }
    if (!password || password.trim() === '') {
      setError('Password is required');
      setLoading(false);
      return;
    }

    // Check username/password in Supabase - fetch role and pin as well
    const { data, error: loginError } = await supabase
      .from('users')
      .select('id, username, password, contact_number, role, pin, setup_token')
      .eq('username', username)
      .eq('password', password)
      .single();

    console.log('Login attempt:', { username, hasData: !!data, error: loginError, role: data?.role });

    

    if (loginError || !data) {
      // increment attempts (only count actual auth attempts)
      const next = attempts + 1;
      setAttempts(next);
      localStorage.setItem('cf_login_attempts', String(next));
      if (next >= 3) {
        const until = Date.now() + 60_000; // 1 minute lock
        setLockUntil(until);
        localStorage.setItem('cf_login_lock_until', String(until));
        setRemaining(60);
        setError('Too many failed attempts. Try again in 60s');
      } else {
        setError('Invalid username or password');
      }
      setLoading(false);
      return;
    }

    // Check if user has setup_token - means they haven't completed account setup
    if (data.setup_token) {
      setError('Account setup not completed. Please check your SMS for the setup link.');
      setLoading(false);
      return;
    }

    // Check if user is admin
    if (data.role === 'admin') {
      // For admin, ask for superpassword (PIN)
      const superpassword = prompt('Enter superpassword (PIN):');
      if (superpassword && superpassword === String(data.pin)) {
        // Admin authenticated successfully
        localStorage.setItem('admin_authenticated', 'true');
        localStorage.setItem('user_id', data.id);
        localStorage.setItem('user_role', data.role);
        // reset attempts on successful authentication
        setAttempts(0);
        localStorage.removeItem('cf_login_attempts');
        setLockUntil(null);
        localStorage.removeItem('cf_login_lock_until');
        setLoading(false);
        navigate('/admin');
        return;
      } else {
        setError('Invalid superpassword');
        setLoading(false);
        return;
      }
    }

    // For regular users, continue with OTP flow
    if (!data.contact_number || data.contact_number.trim() === '') {
      setError('No contact number is associated with this account.');
      
      setLoading(false);
      return;
    }

    const trimmedContactNumber = data.contact_number.trim();
    setContactNumber(trimmedContactNumber);
    setUserId(data.id);

    // reset attempts on successful authentication
    setAttempts(0);
    localStorage.removeItem('cf_login_attempts');
    setLockUntil(null);
    localStorage.removeItem('cf_login_lock_until');
    

    // Request backend to generate and send the OTP
    try {
      const response = await fetch('http://localhost:3001/api/send-otp', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ phoneNumbers: [trimmedContactNumber] })
      });

      const result = await response.json();

      if (response.ok && result.otp) {
        setSentOtp(result.otp);
        setTimer(45);
        setResendClicked(false);
        setStep('otp');
        setInfo('OTP sent to your phone.');
      } else {
          setError('Failed to send OTP.');
        setInfo('');
      }
    } catch (err) {
      setError('Failed to connect to the server.');
      setInfo('');
      // console.error intentionally removed to avoid leaking debug logs in UI
    }
    setLoading(false);
  };

  const handleSendOtp = async () => {
    setError('');
    setInfo('');
    setLoading(true);

    try {
      // don't allow resend while OTP lock is active
      if (otpLockUntil && Date.now() < otpLockUntil) {
        setError(`Resend disabled. Try again in ${otpRemaining}s`);
        setLoading(false);
        return;
      }
      // mark resend clicked immediately so link disappears
      setResendClicked(true);
      const response = await fetch('http://localhost:3001/api/send-otp', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ phoneNumbers: [contactNumber] })
      });

      const result = await response.json();

      if (response.ok && result.otp) {
        setSentOtp(result.otp);
        setTimer(45);
        setInfo('OTP resent to your phone.');
        // keep resendClicked true so link remains hidden until timer resets
      } else {
        setError('Failed to resend OTP.');
        setInfo('');
        setResendClicked(false);
      }
    } catch (err) {
      setError('Failed to connect to the server.');
      setInfo('');
      setResendClicked(false);
    }
    setLoading(false);
  };

  // initialize attempts/lock from localStorage
  useEffect(() => {
    const a = parseInt(localStorage.getItem('cf_login_attempts') || '0', 10) || 0;
    const until = parseInt(localStorage.getItem('cf_login_lock_until') || '0', 10) || null;
    setAttempts(a);
    if (until && until > Date.now()) {
      setLockUntil(until);
      setRemaining(Math.ceil((until - Date.now()) / 1000));
    } else {
      localStorage.removeItem('cf_login_lock_until');
    }
    // init otp attempts/lock
    const oa = parseInt(localStorage.getItem('cf_otp_attempts') || '0', 10) || 0;
    const ountil = parseInt(localStorage.getItem('cf_otp_lock_until') || '0', 10) || null;
    setOtpAttempts(oa);
    if (ountil && ountil > Date.now()) {
      setOtpLockUntil(ountil);
      setOtpRemaining(Math.ceil((ountil - Date.now()) / 1000));
    } else {
      localStorage.removeItem('cf_otp_lock_until');
    }
    // clear resendClicked state when component mounts or lock state is stale
    setResendClicked(false);
  }, []);

  // countdown effect while locked
  useEffect(() => {
    if (!lockUntil) return;
    const iv = setInterval(() => {
      const rem = Math.max(0, Math.ceil((lockUntil - Date.now()) / 1000));
      setRemaining(rem);
      if (rem <= 0) {
        setLockUntil(null);
        setAttempts(0);
        localStorage.removeItem('cf_login_attempts');
        localStorage.removeItem('cf_login_lock_until');
        clearInterval(iv);
      }
    }, 1000);
    return () => clearInterval(iv);
  }, [lockUntil]);

  // countdown effect while otp locked
  useEffect(() => {
    if (!otpLockUntil) return;
    const iv = setInterval(() => {
      const rem = Math.max(0, Math.ceil((otpLockUntil - Date.now()) / 1000));
      setOtpRemaining(rem);
      if (rem <= 0) {
        setOtpLockUntil(null);
        setOtpAttempts(0);
        localStorage.removeItem('cf_otp_attempts');
        localStorage.removeItem('cf_otp_lock_until');
        // unlock resend link when otp lock ends
        setResendClicked(false);
        clearInterval(iv);
      }
    }, 1000);
    return () => clearInterval(iv);
  }, [otpLockUntil]);

  // when the resend cooldown timer reaches zero, allow the Resend link again
  useEffect(() => {
    if (timer === 0 && !otpLockUntil) {
      setResendClicked(false);
    }
  }, [timer, otpLockUntil]);

  // keep error message as the live countdown while locked
  useEffect(() => {
    if (lockUntil && remaining > 0) {
      setError(`Too many failed attempts. Try again in ${remaining}s`);
    } else if (!lockUntil) {
      setError(prev => (prev && prev.startsWith('Too many failed attempts') ? '' : prev));
    }
  }, [lockUntil, remaining]);

  // show otp lock countdown in the error box when OTP locked
  useEffect(() => {
    if (otpLockUntil && otpRemaining > 0) {
      setError(`Too many invalid codes. Try again in ${otpRemaining}s`);
    } else if (!otpLockUntil) {
      setError(prev => (prev && prev.startsWith('Too many invalid codes') ? '' : prev));
    }
  }, [otpLockUntil, otpRemaining]);

  const handleVerify = (e) => {
    e.preventDefault();
    setError('');
    const entered = otp.join('').trim();
    const expected = (sentOtp || '').toString().trim();
    if (entered === '') {
      setError('OTP required');
      return;
    }

    // respect OTP lockout
    if (otpLockUntil && Date.now() < otpLockUntil) {
      setError(`Too many invalid codes. Try again in ${otpRemaining}s`);
      return;
    }

    if (entered === expected && expected !== '') {
      setSuccess(true);
      localStorage.setItem('user_id', userId);
      // reset otp attempts on success
      setOtpAttempts(0);
      localStorage.removeItem('cf_otp_attempts');
      setOtpLockUntil(null);
      localStorage.removeItem('cf_otp_lock_until');
      setTimeout(() => navigate('/dashboard'), 1000);
    } else {
      // increment otp attempts
      const next = otpAttempts + 1;
      setOtpAttempts(next);
      localStorage.setItem('cf_otp_attempts', String(next));
      if (next >= 3) {
        const until = Date.now() + 60_000; // 1 minute
        setOtpLockUntil(until);
        localStorage.setItem('cf_otp_lock_until', String(until));
        setOtpRemaining(60);
        setError('Too many invalid codes. Try again in 60s');
      } else {
        setError('Invalid code');
      }
    }
  };

  return (
    <div className="otp-root">
      <div className="otp-layout">
        <div className="otp-left">
          <img src={logo} alt="CacheFlow Logo" className="otp-logo" />
          <div className="otp-desc">Experience simple, secure, and stress-free banking. Say goodbye to long queues and complex procedures and hello to hassle-free banking with Reen Bank.</div>
        </div>
        <div className="otp-right">
          {step === 'login' && (
            <form onSubmit={handleLogin} className="otp-form">
              <div className="otp-title">Login</div>
              <div className="otp-sub">Enter your username and password to continue</div>
              <div className="input-wrap">
                <input value={username} onChange={e => setUsername(e.target.value)} placeholder="Username" className="otp-input" />
                <span className="input-icon">ðŸ‘¤</span>
              </div>
              <div className="input-wrap">
                <input type={showPassword ? 'text' : 'password'} value={password} onChange={e => setPassword(e.target.value)} placeholder="Password" className="otp-input" />
                <button type="button" aria-label={showPassword ? 'Hide password' : 'Show password'} onClick={() => setShowPassword(p => !p)} className="password-toggle">
                  <img src={showPassword ? hidePng : viewPng} alt={showPassword ? 'Hide' : 'Show'} className="password-toggle-img" />
                </button>
              </div>
              <button type="submit" disabled={loading || (lockUntil && Date.now() < lockUntil)} className="otp-button">{loading ? 'Sending OTP...' : 'Login'}</button>
              {error && <div className="otp-error">{error}</div>}
              {info && <div className="otp-info">{info}</div>}
            </form>
          )}

          {step === 'otp' && (
            <form onSubmit={handleVerify} className="otp-form">
              <div className="otp-title">Text Verification</div>
              <div className="otp-sub">A 6-digit code has been sent to your message <span className="otp-change">Change</span></div>
              <div className="otp-inputs">
                {otp.map((digit, idx) => (
                  <input
                    key={idx}
                    ref={el => inputRefs.current[idx] = el}
                    type="text"
                    inputMode="numeric"
                    maxLength={1}
                    value={digit}
                    onChange={e => handleChange(idx, e.target.value)}
                    onKeyDown={e => handleKeyDown(idx, e)}
                    className="otp-digit"
                  />
                ))}
              </div>
              {!otpLockUntil && (
                <div className="otp-timer">0:{timer.toString().padStart(2, '0')} remaining</div>
              )}
              <button type="submit" disabled={loading || success || (otpLockUntil && Date.now() < otpLockUntil)} className="otp-button">Verify Text</button>
              <div className="otp-resend">Didnâ€™t receive the code? {
                (!resendClicked && timer === 0 && !otpLockUntil) ? (
                  <span className={`otp-resend-link enabled`} onClick={() => handleSendOtp()}>Resend</span>
                ) : (
                  resendClicked ? <span className="otp-resend-requested">Resend requested</span> : <span className="otp-resend-disabled">Resend</span>
                )
              }</div>
              {error && <div className="otp-error">{error}</div>}
              {success && <div className="otp-success">Verified! Login successful.</div>}
            </form>
          )}
        </div>
      </div>
    </div>
  );
};

export default OtpLogin;
